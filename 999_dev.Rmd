---
title: "999_dev"
author: "Puvvula"
date: "2025-12-09"
output: pdf_document
---

```{r}
process_methylation_data <- function(basenames_df, 
                                     pheno_data = NULL,
                                     output_folder,
                                     array_type = c("450k", "EPIC", "EPICv2"),
                                     detection_pval = 0.01,
                                     sample_cutoff = 0.05,
                                     apply_bmiq = TRUE,
                                     apply_combat = TRUE,
                                     batch_variable = NULL,
                                     remove_sex_chr = TRUE,
                                     remove_snps = TRUE,
                                     remove_cross_reactive = TRUE,
                                     verbose = TRUE) {
  
  # Suppress matrixStats useNames deprecation warning
  options(matrixStats.useNames.NA = "deprecated")
  
  # Load required libraries
  require(minfi)
  require(IlluminaHumanMethylation450kanno.ilmn12.hg19)
  require(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
  require(sva)
  require(wateRmelon)
  require(readr)
  require(SummarizedExperiment)
  require(S4Vectors)
  
  array_type <- match.arg(array_type)
  
  # Track probe counts at each step for summary
  probe_counts <- list()
  
  # ========== 0. Validate Inputs and Create Output Folder ==========
  if (verbose) cat("\n=== Validating inputs ===\n")
  
  if (!is.data.frame(basenames_df)) {
    stop("basenames_df must be a data frame")
  }
  
  required_cols <- c("Sample_ID", "folder_location")
  if (!all(required_cols %in% colnames(basenames_df))) {
    stop("basenames_df must contain columns: Sample_ID, folder_location")
  }
  
  if (verbose) {
    cat("Number of samples in basenames_df: ", nrow(basenames_df), "\n")
  }
  
  basenames <- file.path(basenames_df$folder_location, basenames_df$Sample_ID)
  
  missing_files <- c()
  for (i in seq_along(basenames)) {
    red_file <- paste0(basenames[i], "_Red.idat")
    grn_file <- paste0(basenames[i], "_Grn.idat")
    if (!file.exists(red_file) || !file.exists(grn_file)) {
      missing_files <- c(missing_files, basenames_df$Sample_ID[i])
    }
  }
  
  if (length(missing_files) > 0) {
    stop("IDAT files not found for samples: ", paste(missing_files, collapse = ", "))
  }
  
  if (verbose) cat("All IDAT files found\n")
  
  if (!dir.exists(output_folder)) {
    dir.create(output_folder, recursive = TRUE)
    if (verbose) cat("Created output folder: ", output_folder, "\n")
  } else {
    if (verbose) cat("Using existing output folder: ", output_folder, "\n")
  }
  
  # Prepare phenotype data
  if (is.null(pheno_data)) {
    if (verbose) cat("No phenotype data provided. Creating basic pheno_data from basenames_df\n")
    pheno_data <- as.data.frame(basenames_df)
    rownames(pheno_data) <- basenames_df$Sample_ID
  } else {
    if (nrow(pheno_data) != nrow(basenames_df)) {
      stop("pheno_data must have the same number of rows as basenames_df")
    }
    pheno_data <- as.data.frame(pheno_data)
    rownames(pheno_data) <- basenames_df$Sample_ID
  }
  
  # Helper printer
  print_dims <- function(obj, message) {
    if (verbose) {
      cat(message, ": ", nrow(obj), " probes x ", ncol(obj), " samples\n", sep = "")
    }
  }
  
  # ========== 1. Read Raw Data ==========
  if (verbose) cat("\n=== Reading methylation data ===\n")
  rgSet <- read.metharray(basenames = basenames)
  colnames(rgSet) <- basenames_df$Sample_ID
  print_dims(rgSet, "Initial dimensions")
  probe_counts$initial <- nrow(rgSet)
  
  # ========== 2. Sample-level QC (on raw data) ==========
  if (verbose) cat("\n=== Sample-level QC ===\n")
  detP <- detectionP(rgSet)
  colnames(detP) <- basenames_df$Sample_ID
  
  failed_probes_per_sample <- colSums(detP > detection_pval)
  threshold <- sample_cutoff * nrow(rgSet)
  samples_to_remove <- failed_probes_per_sample > threshold
  
  if (verbose) {
    cat("Detection p-value threshold: ", detection_pval, "\n")
    cat("Sample removal threshold: ", sample_cutoff * 100, "% failed probes\n", sep = "")
    cat("Samples failing QC: ", sum(samples_to_remove), "/", ncol(rgSet), "\n")
    if (sum(samples_to_remove) > 0) {
      cat("Sample IDs removed: ", paste(colnames(rgSet)[samples_to_remove], collapse = ", "), "\n")
    }
  }
  
  # Remove poor quality samples from all objects
  rgSet <- rgSet[, !samples_to_remove]
  detP <- detP[, !samples_to_remove, drop = FALSE]
  pheno_data <- pheno_data[!samples_to_remove, , drop = FALSE]
  
  print_dims(rgSet, "After sample removal")
  
  # ========== 3. Normalization (Noob) ==========
  if (verbose) cat("\n=== Normalization (Noob) ===\n")
  mSetSq <- preprocessNoob(rgSet)
  
  if (verbose) {
    cat("Class of mSetSq: ", paste(class(mSetSq), collapse = ", "), "\n")
  }
  print_dims(mSetSq, "After Noob normalization")
  
  # ========== 4. Extract Beta Values (BEFORE probe filtering - include all probes) ==========
  if (verbose) cat("\n=== Extracting beta values ===\n")
  beta <- minfi::getBeta(mSetSq)
  
  if (verbose) {
    cat("Class of beta: ", paste(class(beta), collapse = ", "), "\n")
    cat("is.null(beta): ", is.null(beta), "\n")
  }
  
  if (is.null(beta) || nrow(beta) == 0) {
    stop("getBeta(mSetSq) returned NULL or empty matrix. Check that mSetSq is valid.")
  }
  
  if (verbose) {
    cat("Beta matrix dimensions after getBeta: ", 
        paste(dim(beta), collapse = " x "), "\n")
    cat("Example probe names: ", paste(head(rownames(beta), 3), collapse = ", "), "\n")
  }
  
  print_dims(beta, "After extracting beta values")
  probe_counts$after_noob <- nrow(beta)
  
  # ========== 5. BMIQ Normalization (Optional - BEFORE probe filtering) ==========
  if (apply_bmiq) {
    if (verbose) cat("\n=== Applying BMIQ normalization ===\n")
    
    # Get design vector from the annotation
    if (array_type == "450k") {
      ann450k <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
      design <- rep(NA_integer_, length = nrow(beta))
      names(design) <- rownames(beta)
      
      matched_idx <- match(rownames(beta), rownames(ann450k))
      valid_matches <- !is.na(matched_idx)
      
      design[valid_matches][ann450k$Type[matched_idx[valid_matches]] == "I"] <- 1
      design[valid_matches][ann450k$Type[matched_idx[valid_matches]] == "II"] <- 2
      
      if (verbose) {
        cat("Annotation Type I probes: ", sum(ann450k$Type == "I", na.rm = TRUE), "\n")
        cat("Annotation Type II probes: ", sum(ann450k$Type == "II", na.rm = TRUE), "\n")
        cat("Matches found in beta: ", sum(valid_matches), " out of ", nrow(beta), "\n")
      }
      
    } else if (array_type %in% c("EPIC", "EPICv2")) {
      annEPIC <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
      design <- rep(NA_integer_, length = nrow(beta))
      names(design) <- rownames(beta)
      
      matched_idx <- match(rownames(beta), rownames(annEPIC))
      valid_matches <- !is.na(matched_idx)
      
      design[valid_matches][annEPIC$Type[matched_idx[valid_matches]] == "I"] <- 1
      design[valid_matches][annEPIC$Type[matched_idx[valid_matches]] == "II"] <- 2
      
      if (verbose) {
        cat("Annotation Type I probes: ", sum(annEPIC$Type == "I", na.rm = TRUE), "\n")
        cat("Annotation Type II probes: ", sum(annEPIC$Type == "II", na.rm = TRUE), "\n")
        cat("Matches found in beta: ", sum(valid_matches), " out of ", nrow(beta), "\n")
      }
    }
    
    valid <- !is.na(design)
    
    if (verbose) {
      cat("Probes with valid design assignment: ", sum(valid), " out of ", nrow(beta), "\n")
    }
    
    if (sum(valid) == 0) {
      if (verbose) cat("Warning: No probes with valid design types. Skipping BMIQ.\n")
    } else {
      beta  <- beta[valid, , drop = FALSE]
      design <- design[valid]
      
      design_table <- table(design)
      if (verbose) {
        cat("Probe design distribution:\n")
        print(design_table)
      }
      
      if (length(design_table) < 2) {
        if (verbose) cat("Warning: Only one probe type present. Skipping BMIQ normalization.\n")
      } else {
        beta_bmiq <- beta
        failed_samples <- 0
        
        for (i in seq_len(ncol(beta))) {
          if (verbose && i %% 10 == 0) cat("  Processing sample ", i, "/", ncol(beta), "\n", sep = "")
          
          beta_sample <- beta[, i]
          na_probes <- is.na(beta_sample)
          
          if (sum(na_probes) > 0) {
            beta_sample_clean <- beta_sample[!na_probes]
            design_clean <- design[!na_probes]
          } else {
            beta_sample_clean <- beta_sample
            design_clean <- design
          }
          
          if (length(table(design_clean)) < 2) {
            if (verbose && failed_samples == 0) {
              cat("  Warning: Sample ", i, " missing one probe type. Using original values.\n", sep = "")
            }
            failed_samples <- failed_samples + 1
            next
          }
          
          tryCatch({
            suppressMessages({
              capture.output({
                bmiq_result <- BMIQ(beta_sample_clean, design_clean)
              })
            })
            
            if (sum(na_probes) > 0) {
              beta_bmiq[!na_probes, i] <- bmiq_result$nbeta
            } else {
              beta_bmiq[, i] <- bmiq_result$nbeta
            }
          }, error = function(e) {
            if (verbose && failed_samples == 0) {
              cat("  Warning: BMIQ failed for sample ", i, ". Using original values.\n", sep = "")
            }
            failed_samples <<- failed_samples + 1
          })
        }
        
        beta <- beta_bmiq
        
        if (failed_samples > 0 && verbose) {
          cat("BMIQ failed for ", failed_samples, " sample(s). Using original values for those samples.\n", sep = "")
        }
        if (verbose) cat("BMIQ normalization complete\n")
      }
    }
    
    print_dims(beta, "After BMIQ normalization")
    
    # Clamp beta values to [0, 1] range - keep as matrix using element-wise assignment
    beta[beta < 0] <- 0
    beta[beta > 1] <- 1
    
    if (verbose) {
      cat("Beta values clamped to [0, 1] range\n")
      cat("Min beta value after clamping: ", min(beta), "\n")
      cat("Max beta value after clamping: ", max(beta), "\n")
    }
  }
  
  # ========== 6. Batch Correction (Optional, AFTER BMIQ) ==========
  if (apply_combat && !is.null(batch_variable)) {
    if (verbose) cat("\n=== Applying ComBat batch correction ===\n")
    
    if (!(batch_variable %in% colnames(pheno_data))) {
      stop("Batch variable '", batch_variable, "' not found in pheno_data")
    }
    
    batch <- pheno_data[[batch_variable]]
    
    # Ensure beta is a matrix
    if (!is.matrix(beta)) {
      beta <- as.matrix(beta)
    }
    
    if (verbose) {
      cat("Beta matrix dimensions before ComBat: ", paste(dim(beta), collapse = " x "), "\n")
      cat("Batch variable table:\n")
      print(table(batch, useNA = "ifany"))
    }
    
    # Safety checks before ComBat
    if (is.null(dim(beta)) || nrow(beta) == 0L) {
      if (verbose) cat("Warning: No probes or invalid beta structure; skipping ComBat.\n")
    } else if (any(is.na(batch))) {
      if (verbose) cat("Warning: Batch vector contains NA values; skipping ComBat.\n")
    } else if (length(batch) != ncol(beta)) {
      if (verbose) cat("Warning: Batch vector length (", length(batch), ") does not match number of samples (", ncol(beta), "); skipping ComBat.\n", sep = "")
    } else {
      batch_table <- table(batch)
      if (any(batch_table < 2) && verbose) {
        cat("Warning: Some batches have fewer than 2 samples. ComBat may fail.\n")
        print(batch_table)
      }
      
      tryCatch({
        batch <- as.factor(batch)
        
        beta_combat <- ComBat(dat = beta, batch = batch, mod = NULL, par.prior = TRUE)
        
        # Ensure result is a matrix with proper dimensions
        if (!is.matrix(beta_combat)) {
          beta_combat <- as.matrix(beta_combat)
          rownames(beta_combat) <- rownames(beta)
          colnames(beta_combat) <- colnames(beta)
        }
        
        beta <- beta_combat
        
        if (verbose) cat("ComBat batch correction complete\n")
      }, error = function(e) {
        if (verbose) {
          cat("Warning: ComBat failed. Proceeding without batch correction.\n")
          cat("Error message: ", e$message, "\n")
        }
      })
    }
    
    # Ensure beta is a matrix after ComBat
    if (!is.matrix(beta)) {
      beta <- as.matrix(beta)
    }
    
    # Clamp beta values to [0, 1] range after batch correction - keep as matrix
    beta[beta < 0] <- 0
    beta[beta > 1] <- 1
    
    print_dims(beta, "After ComBat batch correction")
    
    if (verbose) {
      cat("Beta values clamped to [0, 1] range after ComBat\n")
      cat("Min beta value: ", min(beta), "\n")
      cat("Max beta value: ", max(beta), "\n")
    }
  }
  
  probe_counts$after_bmiq_combat <- nrow(beta)
  
  # ========== 7. Probe-level QC (detection p-value) - AFTER normalization ==========
  if (verbose) cat("\n=== Probe-level QC (detection p-value) ===\n")
  failed_probe_count <- rowSums(detP > detection_pval)
  keep_probes <- failed_probe_count == 0
  
  probes_removed_detection <- sum(!keep_probes)
  if (verbose) {
    cat("Probes with failed detection (p > ", detection_pval, ") in â‰¥1 sample: ", 
        probes_removed_detection, "\n", sep = "")
  }
  
  beta <- beta[keep_probes, , drop = FALSE]
  detP <- detP[keep_probes, , drop = FALSE]
  
  print_dims(beta, "After removing failed probes")
  probe_counts$after_detection_filter <- nrow(beta)
  
  # ========== 8. Remove Sex Chromosome Probes ==========
  probes_removed_sex <- 0
  if (remove_sex_chr) {
    if (verbose) cat("\n=== Removing sex chromosome probes ===\n")
    
    if (array_type == "450k") {
      data(Locations)
      annotation <- Locations
    } else if (array_type %in% c("EPIC", "EPICv2")) {
      data(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
      annotation <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
    }
    
    sex_probes <- rownames(annotation)[annotation$chr %in% c("chrX", "chrY")]
    keep_probes <- !(rownames(beta) %in% sex_probes)
    probes_removed_sex <- sum(!keep_probes)
    
    if (verbose) {
      cat("Sex chromosome probes removed: ", probes_removed_sex, "\n")
    }
    
    beta <- beta[keep_probes, , drop = FALSE]
    detP <- detP[keep_probes, , drop = FALSE]
    
    print_dims(beta, "After removing sex chromosome probes")
    probe_counts$after_sex_chr_filter <- nrow(beta)
  }
  
  # ========== 9. Remove Cross-Reactive Probes ==========
  probes_removed_crossreactive <- 0
  if (remove_cross_reactive) {
    if (verbose) cat("\n=== Removing cross-reactive probes ===\n")
    
    tryCatch({
      xReactiveProbes <- read_csv(
        "https://epigen.ccm.sickkids.ca/sample-report/data/quality_control/cross_reactive_probes.csv",
        col_names = c("TargetID"),
        show_col_types = FALSE
      )
      
      keep_probes <- !(rownames(beta) %in% xReactiveProbes$TargetID)
      probes_removed_crossreactive <- sum(!keep_probes)
      
      if (verbose) {
        cat("Cross-reactive probes removed: ", probes_removed_crossreactive, "\n")
      }
      
      beta <- beta[keep_probes, , drop = FALSE]
      detP <- detP[keep_probes, , drop = FALSE]
      
      print_dims(beta, "After removing cross-reactive probes")
      probe_counts$after_crossreactive_filter <- nrow(beta)
      
    }, error = function(e) {
      if (verbose) cat("Warning: Could not load cross-reactive probes list. Skipping this step.\n")
      probe_counts$after_crossreactive_filter <<- nrow(beta)
    })
  }
  
  # ========== 10. Remove SNP Probes ==========
  probes_removed_snps <- 0
  if (remove_snps) {
    if (verbose) cat("\n=== Removing probes with SNPs ===\n")
    
    initial_probes <- nrow(beta)
    
    if (array_type == "450k") {
      ann450k <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
      common_probes <- intersect(rownames(beta), rownames(ann450k))
      beta_temp <- beta[common_probes, , drop = FALSE]
      
      grSet_temp <- makeGenomicRatioSetFromMatrix(
        beta_temp,
        array = "IlluminaHumanMethylation450k",
        annotation = "ilmn12.hg19",
        what = "Beta"
      )
    } else if (array_type %in% c("EPIC", "EPICv2")) {
      annEPIC <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
      common_probes <- intersect(rownames(beta), rownames(annEPIC))
      beta_temp <- beta[common_probes, , drop = FALSE]
      
      grSet_temp <- makeGenomicRatioSetFromMatrix(
        beta_temp,
        array = "IlluminaHumanMethylationEPIC",
        annotation = "ilm10b4.hg19",
        what = "Beta"
      )
    }
    
    grSet_temp <- dropLociWithSnps(grSet_temp, snps = c("SBE", "CpG"), maf = 0)
    
    snp_filtered_probes <- rownames(grSet_temp)
    keep_probes <- rownames(beta) %in% snp_filtered_probes
    probes_removed_snps <- initial_probes - sum(keep_probes)
    
    if (verbose) {
      cat("Probes with SNPs removed: ", probes_removed_snps, "\n")
    }
    
    beta <- beta[keep_probes, , drop = FALSE]
    detP <- detP[keep_probes, , drop = FALSE]
    
    print_dims(beta, "After removing SNP probes")
    probe_counts$after_snp_filter <- nrow(beta)
  }
  
  # ========== 11. Create Final GenomicRatioSet ==========
  if (verbose) cat("\n=== Creating final GenomicRatioSet ===\n")
  
  if (nrow(beta) == 0) {
    stop("Beta matrix is empty. Something went wrong in filtering/normalization steps.")
  }
  
  if (array_type == "450k") {
    ann450k <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
    valid_probes <- intersect(rownames(beta), rownames(ann450k))
    
    if (verbose) {
      cat("Probes in beta: ", nrow(beta), "\n")
      cat("Valid probes matching 450k annotation: ", length(valid_probes), "\n")
    }
    
    if (length(valid_probes) == 0) {
      stop("No row names in beta match IlluminaHumanMethylation450k probe names. ",
           "Check that rownames are cg IDs (e.g., cg00000029, cg00000108, ...).")
    }
    
    beta <- beta[valid_probes, , drop = FALSE]
    beta <- beta[order(match(rownames(beta), rownames(ann450k))), , drop = FALSE]
    
    grSet <- makeGenomicRatioSetFromMatrix(
      beta,
      array = "IlluminaHumanMethylation450k",
      annotation = "ilmn12.hg19",
      what = "Beta"
    )
    
  } else if (array_type %in% c("EPIC", "EPICv2")) {
    annEPIC <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
    valid_probes <- intersect(rownames(beta), rownames(annEPIC))
    
    if (verbose) {
      cat("Probes in beta: ", nrow(beta), "\n")
      cat("Valid probes matching EPIC annotation: ", length(valid_probes), "\n")
    }
    
    if (length(valid_probes) == 0) {
      stop("No row names in beta match IlluminaHumanMethylationEPIC probe names.")
    }
    
    beta <- beta[valid_probes, , drop = FALSE]
    beta <- beta[order(match(rownames(beta), rownames(annEPIC))), , drop = FALSE]
    
    grSet <- makeGenomicRatioSetFromMatrix(
      beta,
      array = "IlluminaHumanMethylationEPIC",
      annotation = "ilm10b4.hg19",
      what = "Beta"
    )
  }
  
  # Assign phenotype data using colData
  pheno_data <- as.data.frame(pheno_data)
  pheno_data <- pheno_data[colnames(grSet), , drop = FALSE]
  colData(grSet) <- S4Vectors::DataFrame(pheno_data)
  
  print_dims(grSet, "Final dataset")
  
  if (verbose) {
    cat("\n=== Processing complete ===\n")
    cat("Total probes retained: ", nrow(grSet), " (", 
        round(nrow(grSet) / nrow(rgSet) * 100, 1), "% of original)\n", sep = "")
    cat("Total samples retained: ", ncol(grSet), " (", 
        round(ncol(grSet) / nrow(basenames_df) * 100, 1), "% of original)\n", sep = "")
  }
  
  # ========== 12. Save Results ==========
  if (verbose) cat("\n=== Saving results to ", output_folder, " ===\n", sep = "")
  
  grSet_file <- file.path(output_folder, "grSet.rda")
  save(grSet, file = grSet_file)
  if (verbose) cat("Saved grSet to: ", grSet_file, "\n")
  
  beta_file <- file.path(output_folder, "beta.rda")
  save(beta, file = beta_file)
  if (verbose) cat("Saved beta to: ", beta_file, "\n")
  
  detP_file <- file.path(output_folder, "detP.rda")
  save(detP, file = detP_file)
  if (verbose) cat("Saved detP to: ", detP_file, "\n")
  
  pheno_data_file <- file.path(output_folder, "pheno_data.rda")
  save(pheno_data, file = pheno_data_file)
  if (verbose) cat("Saved pheno_data to: ", pheno_data_file, "\n")
  
  summary_file <- file.path(output_folder, "processing_summary.txt")
  sink(summary_file)
  cat("DNA Methylation Processing Summary\n")
  cat("===================================\n\n")
  cat("Processing Date: ", as.character(Sys.time()), "\n\n")
  cat("Array Type: ", array_type, "\n")
  cat("Detection p-value threshold: ", detection_pval, "\n")
  cat("Sample cutoff: ", sample_cutoff * 100, "%\n", sep = "")
  cat("BMIQ applied: ", apply_bmiq, "\n")
  cat("ComBat applied: ", apply_combat, "\n")
  if (!is.null(batch_variable)) cat("Batch variable: ", batch_variable, "\n")
  cat("Sex chromosomes removed: ", remove_sex_chr, "\n")
  cat("SNP probes removed: ", remove_snps, "\n")
  cat("Cross-reactive probes removed: ", remove_cross_reactive, "\n\n")
  
  cat("========== PROBE FILTERING SUMMARY ==========\n\n")
  cat("Initial probes (raw): ", probe_counts$initial, "\n")
  cat("After Noob normalization: ", probe_counts$after_noob, " (no probes removed)\n")
  cat("After BMIQ/ComBat normalization: ", probe_counts$after_bmiq_combat, " (no probes removed)\n")
  cat("After detection p-value filtering: ", probe_counts$after_detection_filter, 
      " (removed: ", probes_removed_detection, ")\n", sep = "")
  
  if (remove_sex_chr) {
    cat("After sex chromosome removal: ", probe_counts$after_sex_chr_filter, 
        " (removed: ", probes_removed_sex, ")\n", sep = "")
  }
  
  if (remove_cross_reactive) {
    cat("After cross-reactive removal: ", probe_counts$after_crossreactive_filter, 
        " (removed: ", probes_removed_crossreactive, ")\n", sep = "")
  }
  
  if (remove_snps) {
    cat("After SNP removal: ", probe_counts$after_snp_filter, 
        " (removed: ", probes_removed_snps, ")\n", sep = "")
  }
  
  total_probes_removed <- probe_counts$initial - nrow(grSet)
  cat("\nTotal probes removed: ", total_probes_removed, 
      " (", round(total_probes_removed / probe_counts$initial * 100, 1), "% of original)\n\n", sep = "")
  
  cat("========== SAMPLE SUMMARY ==========\n\n")
  cat("Initial samples: ", nrow(basenames_df), "\n")
  cat("Final samples: ", ncol(grSet), "\n")
  cat("Samples removed: ", nrow(basenames_df) - ncol(grSet), "\n\n")
  
  cat("========== FINAL DATASET ==========\n\n")
  cat("Final dimensions: ", nrow(grSet), " probes x ", ncol(grSet), " samples\n")
  cat("Probes retained: ", round(nrow(grSet) / probe_counts$initial * 100, 1), "% of original\n", sep = "")
  cat("Samples retained: ", round(ncol(grSet) / nrow(basenames_df) * 100, 1), "% of original\n", sep = "")
  
  cat("\n========== BETA VALUE RANGE ==========\n\n")
  cat("Min beta value: ", min(beta), "\n")
  cat("Max beta value: ", max(beta), "\n")
  cat("Mean beta value: ", mean(beta), "\n")
  cat("Median beta value: ", median(beta), "\n")
  
  sink()
  
  if (verbose) cat("Saved processing summary to: ", summary_file, "\n")
  if (verbose) cat("\n=== All files saved successfully ===\n")
  
  invisible(list(
    grSet = grSet,
    beta = beta,
    detP = detP,
    pheno_data = pheno_data,
    output_folder = output_folder,
    probe_counts = probe_counts
  ))
}
```

